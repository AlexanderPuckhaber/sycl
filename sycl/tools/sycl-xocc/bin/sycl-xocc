#!/bin/bash
# This is an extra layer of abstraction on top of the shell invocing the
# SDx compiler. As SPIR/LLVM-IR is a second class citizen in SDx for the
# moment it has some little niggling details that need worked on and the idea
# is that this script will work around those with some aid from Clang/LLVM.
#
# One of the main examples is that SDx can only compile one kernel from LLVM-BC
# at a time and it requires the kernels name (also required for kernel specific
# optimizations). This poses a problem as there can be multiple kernels in a
# file. And when making a normal naked SDx -c command in the driver
# you won't have the neccesarry information as the command is generated before
# the file's have even started to be compiled (Perhaps there is that I am
# unaware of). So no kernel names and no idea how many SDx commands you'd need
# to generate per file (no idea how many kernels are in a file).
#
# This works around that by using an opt (kernelNameGen) pass that generates
# an intermediate file with the needed information that we eat up and can then
# loop over each kernel in a file. It's simple at the moment just kernel names,
# but could expand in the future to include optimization information for each
# kernel.
#
# Arguments:
# $1  == SDx's SDx bin directory where the real shell invocation that invokes
#        the SDx compiler resides
# $2  == path to the clang driver that's executing the shell script (e.g.
#         your compiled Clang's build/bin)
# $3  == The name of the source file without file extensions or temporary
#        manglings, mostly used to generate some intermediate file names
# $4  == The initial input file name, currently a .o file that's actually a .bc
#        file in disguise
# $5  == The systems temporary directory where we'll deposit some intermediate
#        files
# $6  == The name we wish to give our final output .xcl binary, important that it
#       is consistent with what the driver expects it to be.
# $7  == The name of the file containing additional args for v++ -c
# $8  == The name of the file containing additional args for v++ -l
# $9  == The name of the target hw/hw_emu/sw_emu
# $10 == The flow to use hls/spir

set -e # stop on error
set -x
CWD=$(pwd)

# TODO: Pass an argument through the driver to set options like XILINX_PLATFORM,
# the environment variables are a quick workaround to swap boards.
usage() { echo $0: error: $2 >&2; exit $1; }

SDX_BIN_PATH_DIR="$1"
DRIVER_PATH_DIR="$2"
# excluding file extension e.g. .cpp and path
SOURCE_FILE_NAME="$3"
# input file name including extensions and path
INPUT_FILE_NAME="$4"
TMP_DIR="$5"
# output file name including extensions and path
OUTPUT_FILE_NAME="$6"
ADDITIONAL_COMPILE_FILE="$7"
ADDITIONAL_LINK_FILE="$8"
XCL_EMULATION_MODE=$9
shift
XLX_COMPILE_FLOW=$9

echo "COMPILE FLOW: ${XLX_COMPILE_FLOW}"

# Make this a parameter passed in from Clang at some point
export VERBOSE=1

if [[ -z "${SDX_BIN_PATH_DIR}" ]]; then
  usage 1 "no SDx bin directory"
fi

if [[ -z "${DRIVER_PATH_DIR}" ]]; then
  usage 2 "no driver path specified"
fi

if [[ -z "${SOURCE_FILE_NAME}" ]]; then
  usage 3 "no source file name"
fi

if [[ -z "${INPUT_FILE_NAME}" ]]; then
  usage 4 "no input file name"
fi

if [[ -z "${TMP_DIR}" ]]; then
  usage 5 "no temporary directory specified"
fi

if [[ -z "${OUTPUT_FILE_NAME}" ]]; then
  usage 6 "no final output file specified"
fi

if [[ -z "${ADDITIONAL_COMPILE_FILE}" ]]; then
  usage 7 "no additional compile args file"
fi

if [[ -z "${ADDITIONAL_LINK_FILE}" ]]; then
  usage 8 "no additional link args file"
fi

if [[ -z "${XCL_EMULATION_MODE}" ]]; then
  usage 9 "no target specified"
fi

if [[ -z "${XLX_COMPILE_FLOW}" ]]; then
  usage 10 "no compile flow specified"
fi

# Setup SDx related env variables
VITIS_VERSION=$(realpath $SDX_BIN_PATH_DIR/.. | xargs basename)
if [[ ! -d "$SDX_BIN_PATH_DIR" ]]; then
  usage 8 "path to SDx bin directory is not a valid directory"
else
  # Hardcoded path from the bin directory that xocc is stored in, works for now
  # but a future TODO might be to allow this to be optionally specified as an
  # ENV variable

  SDX_LIB_SPIR="$SDX_BIN_PATH_DIR/../lnx64/lib/libspir64-39-hls.bc"
  if [[ ! -f "$SDX_LIB_SPIR" ]]; then
    SDX_LIB_SPIR="$SDX_BIN_PATH_DIR/../../../Vitis_HLS/$VITIS_VERSION/lnx64/lib/libspir64-39-hls.bc"
    if [[ ! -f "$SDX_LIB_SPIR" ]]; then
      usage 9 "could not find SDx's libspir64-39-hls.bc"
    fi
  fi
  # It says 3.9, but trust us this is Clang/LLVM 7..
  if [[ ! -z "$XILINX_CLANG_39_BUILD_PATH" ]]; then
    SDX_CLANG_LLVM_BIN=$XILINX_CLANG_39_BUILD_PATH
  else
    SDX_CLANG_LLVM_BIN="$SDX_BIN_PATH_DIR/../lnx64/tools/clang-3.9-csynth/bin"
    if [[ ! -f "$SDX_CLANG_LLVM_BIN/llvm-as" ]]; then
      SDX_CLANG_LLVM_BIN="$SDX_BIN_PATH_DIR/../../../Vitis_HLS/$VITIS_VERSION/lnx64/tools/clang-3.9-csynth/bin"
      if [[ ! -f "$SDX_CLANG_LLVM_BIN/llvm-as" ]]; then
        usage 9 "could not find SDx's binary directory"
      fi
    fi
  fi

  SDX="$SDX_BIN_PATH_DIR/v++"
  if [[ ! -f "$SDX" ]]; then
    echo "[INFO] Could not find v++ executable in $SDX_BIN_PATH_DIR"
    echo "[INFO] Try with xocc..."
    SDX="$SDX_BIN_PATH_DIR/xocc"
    if [[ ! -f "$SDX" ]]; then
      usage 10 "could not find xocc or v++ in $SDX_BIN_PATH_DIR"
    fi
  fi
fi

if [[ -f "$SDX_CLANG_LLVM_BIN/xilinx-dataflow-lawyer" ]];then
  function cleanup {
    umount $SDX_CLANG_LLVM_BIN/xilinx-dataflow-lawyer || sudo umount $SDX_CLANG_LLVM_BIN/xilinx-dataflow-lawyer
  }

  trap cleanup EXIT
  mount --bind $(which echo) $SDX_CLANG_LLVM_BIN/xilinx-dataflow-lawyer || sudo mount --bind $(which echo) $SDX_CLANG_LLVM_BIN/xilinx-dataflow-lawyer
fi

# Setup Clang/LLVM related env variables
if [[ ! -d "$DRIVER_PATH_DIR" ]]; then
  usage 11 "path to driver directory is not a valid directory"
else
  # Perhaps not as important that the linker is the one packaged with the Clang
  # build (although if the linker version is too different it can inject
  # incorrect IR during the link process), but it's very important that Opt is
  # so that it's packaged with the correct LLVM passes.
  OPT="$DRIVER_PATH_DIR/opt"
  if [[ ! -f "$OPT" ]]; then
    usage 12 "no llvm opt executable found in $DRIVER_PATH_DIR"
  fi

  LLVM_LINK="$DRIVER_PATH_DIR/llvm-link"
  if [[ ! -f "$LLVM_LINK" ]]; then
    usage 13 "no llvm-link executable found in $LLVM_LINK"
  fi
fi

if [[ ! -d "${TMP_DIR}" ]]; then
  usage 14 "the path given for the temporary directory is an invalid directory"
fi

# Should point to whatever Clang has decided is the temporary directory
TMP_PATH="$(mktemp ${TMP_DIR}/sycl-xocc.XXXXXX)"



set +e
# allow faillures because empty string is good default
# This make debugging easier.
ADDITIONAL_COMPILE_ARGS=$(cat ${ADDITIONAL_COMPILE_FILE})
ADDITIONAL_LINK_ARGS=$(cat ${ADDITIONAL_LINK_FILE})
set -e

KERNELPROP="${TMP_PATH}_KernelProperties_${SOURCE_FILE_NAME}.bash"

cp "$INPUT_FILE_NAME" "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels.bc"

if [[ "${XLX_COMPILE_FLOW}" == "hls" ]]; then
  echo "Using HLS flow"
  $OPT --sycl-xocc -preparesycl -globaldce -O3 -globaldce -globaldce -kernelPropGen \
    --sycl-kernel-propgen-output $KERNELPROP \
    -inSPIRation \
    "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels.bc" -o "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-optimized.bc"
  EXTRA_LD_ARGS='--sycl-xlx-hls'
else
  # -flat-address-space defines the generic address space we wish to deduce to
  # something concrete, used by the infer-address-spaces pass which is slightly
  # modified from the upstream implementation to take this argument to avoid
  # adding a new LLVM Target that will largelly be unused right now..
  $OPT --sycl-xocc -preparesycl -globaldce -inline -infer-address-spaces -globaldce -O3 -globaldce\
    -flat-address-space=0 -globaldce  -globaldce -kernelPropGen \
    --sycl-kernel-propgen-output $KERNELPROP \
    --sycl-xlx-oclmd -inSPIRation \
    "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels.bc" -o "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-optimized.bc"
  EXTRA_LD_ARGS=''
fi

# Link our SDx SPIR binaries in
$LLVM_LINK "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-optimized.bc" \
  --only-needed $SDX_LIB_SPIR -o "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.xpirbc"

# Using the LLVM Linker will add more incompatible IR so run the downgrader in
# a second pass afterwards, rather than once before in the first opt pass
# and then again after linking.
#
# We also only wish to emit LLVM IR assembly language format and not bitcode
# format as we currently use the llvm assembler packaged with xocc to generate
# our final bitcode file.
$OPT --sycl-xocc --sycl-remove-annotations ${EXTRA_LD_ARGS} -S -preparesycl -globaldce \
  "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.xpirbc" -o \
  "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.simple.xpirbc"

$OPT --sycl-xocc -S -O3 -xoccIRDowngrader \
  "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.simple.xpirbc" -o \
  "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.opt.ll"

# Our bash file containing kernel property environment variables is placed in
# the systems temporary directory (or wherever the Clang driver is told is the
# temporary directory) and is postfixed with the source files name. It's
# generated by the kernelPropertiesGen OPT pass.
source $KERNELPROP

if [[ ! -z "${SYCL_XOCC_MANUAL_EDIT}" ]]; then
  echo "Please edit ${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.opt.ll"
  echo "Kernel name: ${KERNEL_NAME_ARRAY[0]}"
  read -p "Press return to resume compilation flow"
fi

if [[ "${XLX_COMPILE_FLOW}" == "hls" ]]; then
  VITIS_IR_INPUT="${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.opt.bc"
else
  VITIS_IR_INPUT="${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.opt.xpirbc"
fi
# Generate our final bitcode file with the xocc llvm-as (Clang/LLVM 7 for now)
# this is to work around a problem with the ByVal attribute. The bitcode that
# contains ByVal generated by newer Clang/LLVM (9~) is incompatible with the
# bitcode in Clang/LLVM 7 based xocc, it will kill the reader. So we work around
# it by compiling the IR to BC using the llvm-as from xocc and some minor
# massaging in the xoccIRDowngrader
$SDX_CLANG_LLVM_BIN/llvm-as \
  "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked.opt.ll" -o \
  "${VITIS_IR_INPUT}"

if [[ ! ${#KERNEL_NAME_ARRAY[@]} -eq 0 ]]; then

  echo "Building ${#KERNEL_NAME_ARRAY[@]} Kernels..."
  # Compile all Kernels in the source file to seperate .xo ("object") files
  # and add them to the list of kernels to be linked
  LINKER_LIST=""
  for ((i=0;i<${#KERNEL_NAME_ARRAY[@]};++i)); do
  if [[ -n "${KERNEL_NAME_ARRAY[i]}" ]]; then
    if [[ ! -z "$VERBOSE" ]]; then
      echo "Invoking Kernel Compilation with $SDX"
      echo "--target: $XCL_EMULATION_MODE"
      echo "--platform: $XILINX_PLATFORM"
      echo "Compiling kernel: ${KERNEL_NAME_ARRAY[i]}"
      echo "Outputting file to: ${TMP_PATH}_${KERNEL_NAME_ARRAY[i]}.xo"
      echo "Input file is: ${VITIS_IR_INPUT}"
    fi

    $SDX --target $XCL_EMULATION_MODE --platform $XILINX_PLATFORM \
      --advanced.param param:compiler.hlsDataflowStrictMode=off \
      --save-temps -c -k "${KERNEL_NAME_ARRAY[i]}" -o "${TMP_PATH}_${KERNEL_NAME_ARRAY[i]}.xo" \
      "${VITIS_IR_INPUT}" \
      $ADDITIONAL_COMPILE_ARGS ${EXTRA_KERNEL_PARAMS_ARRAY[i]} &
      LINKER_LIST="${TMP_PATH}_${KERNEL_NAME_ARRAY[i]}.xo $LINKER_LIST"
  fi
  done

  for job in `jobs -p`
  do
    wait $job
  done

  if [[ ! -z "$SYCL_XOCC_REMOTE_LINK_HOST" ]]; then
    if [[ -z "$SYCL_XOCC_REMOTE_TMP" ]]; then 
      SYCL_XOCC_REMOTE_TMP_DIR="/tmp/sycl_xoccc_remote_linker"
    else
      SYCL_XOCC_REMOTE_TMP_DIR="$SYCL_XOCC_REMOTE_TMP/sycl_xocc_remote_linker"
    fi
    REMOTE_CMD="rm -rf $SYCL_XOCC_REMOTE_TMP_DIR ; mkdir -p $SYCL_XOCC_REMOTE_TMP_DIR"
    ssh -t $SYCL_XOCC_REMOTE_LINK_HOST "$REMOTE_CMD"
    REMOTE_LINKER_LIST=""
    for OBJECT in $LINKER_LIST ; do
      REMOTE_LINKER_LIST="$(basename -- $OBJECT) $REMOTE_LINKER_LIST"
    done
    REMOTE_OUT="$(basename -- $OUTPUT_FILE_NAME)"
    TMP_SCRIPT=${TMP_PATH}_linker_script.sh
    echo "cd $SYCL_XOCC_REMOTE_TMP_DIR" > $TMP_SCRIPT
    echo "export PLATFORM_REPO_PATHS=$SYCL_XOCC_REMOTE_LINKER_PLATFORM_PATHS" >> $TMP_SCRIPT
    echo "$SDX --xp param:compiler.hlsDataflowStrictMode=off $DDR_BANK_ARGS --target $XCL_EMULATION_MODE --platform $XILINX_PLATFORM -l --save-temps -o "$REMOTE_OUT" $REMOTE_LINKER_LIST $ADDITIONAL_LINK_ARGS" >> $TMP_SCRIPT
    scp $TMP_SCRIPT $LINKER_LIST $SYCL_XOCC_REMOTE_LINK_HOST:$SYCL_XOCC_REMOTE_TMP_DIR
    REMOTE_CMD="bash ${SYCL_XOCC_REMOTE_TMP_DIR}/$(basename -- $TMP_SCRIPT)"
    ssh $SYCL_XOCC_REMOTE_LINK_HOST "$REMOTE_CMD"
    scp $SYCL_XOCC_REMOTE_LINK_HOST:$SYCL_XOCC_REMOTE_TMP_DIR/$REMOTE_OUT $OUTPUT_FILE_NAME
  else 
    LINKER_WD=${TMP_PATH}_${SOURCE_FILE_NAME}_linker
    rm -rf $LINKER_WD
    mkdir -p $LINKER_WD
      cd $LINKER_WD

    echo "LINKER_LIST:${LINKER_LIST}"
    # \todo Revisit removal of hlsDataflowStrictMode in the future to see if we
    # can compile for hw_emu with it on or if it outputs clearer diagnostics so
    # we can track down the problem (when I tested this it seems that the call
    # to log the error was possibly broken)
    $SDX --xp param:compiler.hlsDataflowStrictMode=off $DDR_BANK_ARGS \
      --target $XCL_EMULATION_MODE --platform $XILINX_PLATFORM -l \
      --save-temps -o "$OUTPUT_FILE_NAME" $LINKER_LIST $ADDITIONAL_LINK_ARGS
    
    cd $CWD
    cp -rf $LINKER_WD/* .
  fi

  # This step is unconnected to the generation of the final xcl binary, it dumps
  # useful debug information from the final generated xcl binary into the temp
  # directory. E.g. what args are bound to which banks, overall kernel signature
  # etc.
  if [ ! -z "$XILINX_XRT" ] && [ ! -z "$VERBOSE" ]; then
    $XILINX_XRT/bin/xclbinutil --info --input "$OUTPUT_FILE_NAME" \
      &> "$OUTPUT_FILE_NAME.xclbinutil.dump"
  fi
fi

# Important these are cleaned all the time or they can kill compilation if
# swapping between sw_emu, hw_emu and hw or even between different versions of
# SDAccel. Explicitly comment this out if you need the .xo's
if [[ ! ${#KERNEL_NAME_ARRAY[@]} -eq 0 ]]; then
  for index in "${KERNEL_NAME_ARRAY[@]}"; do
  if [[ -n "$index" ]]; then
    rm "${TMP_PATH}_$index.xo"
  fi
  done
fi

# if [[ ! -z "$VERBOSE" ]]; then
#   rm -f "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-linked*.xpirbc"
#   rm "${TMP_PATH}_${SOURCE_FILE_NAME}_kernels-optimized.bc"
#   rm "${TMP_PATH}_KernelProperties_${SOURCE_FILE_NAME}.bash"
# fi

